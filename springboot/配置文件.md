#### @Value

+ 用xml配置

```java
    /*
    * <bean class = "Person">
    *      <property name="name" value="字面量/${key}从环境变量，配置文件中获取值/#{SPEL}">
    *      </proerty>
    * </bean>
    * */	
```

+ @Value用法类似

#### @Configurationproperties

```java
#### Using the `@Value("${property}")` annotation to inject configuration properties can sometimes be cumbersome, especially if you are working with multiple properties or your data is hierarchical in nature. Spring Boot provides an alternative method of working with properties that lets strongly typed beans govern and validate the configuration of your application

翻译：用@Value注解注入配置属性有时候是笨重的，尤其你的属性比较多或者你的数据本质上是分层的。Springboot提供了另一种方法处理配置属性，允许强类型的bean处理和验证你的配置。
```

+ @Configurationproperties Validation

```java
Spring Boot attempts to validate `@ConfigurationProperties` classes whenever they are annotated with Spring’s `@Validated` annotation. You can use JSR-303 `javax.validation` constraint annotations directly on your configuration class. To do so, ensure that a compliant JSR-303 implementation is on your classpath and then add constraint annotations to your fields,
翻译：Springboot企图验证`@ConfigurationProperties` 类当他们被Spring@Validated注解作用时。你可以使用JSR-303 `javax.validation`约束注解直接在你的配置类上，为了这么做，确保你的类路径上有兼容的JSR-303实现，然后在你的属性上添加约束注解。
@ConfigurationProperties(prefix="acme")
@Validated
public class AcmeProperties {

	@NotNull
	private InetAddress remoteAddress;

	@Valid
	private final Security security = new Security();

	// ... getters and setters

	public static class Security {

		@NotEmpty
		public String username;

		// ... getters and setters

	}

}
```

+ @ConfigurationProperties和@Value获取值比较

|                      | @ConfigurationProperties   | @Value       |
| -------------------- | -------------------------- | ------------ |
| 功能                 | 批量注入配置为文件中的属性 | 一个一个注入 |
| 松散绑定（松散语法） | 支持                       | 不支持       |
| 元数据支持           | 支持                       | 不支持       |
| SPEL                 | 不支持                     | 支持         |
| JSR303数据校验       | 支持                       | 不支持       |
| 复杂类型封装         | 支持                       | 不支持       |

+ 配置文件是yml/properties都能获取
+ 如果在某个业务逻辑我们需要使用配置文件中的某项值，我们就使用@Value
+ 如果专门编写了一个javabean和配置文件进行映射，就使用@ConfigurationProperties

+ 配置文件注入值数据校验

```java
@Component
@ConfigurationProperties(prefix = "person")
@Validated
public class Person {


    /*
    * <bean class = "Person">
    *      <property name="name" value="字面量/${key}从环境变量，配置文件中获取值/#{SPEL}">
    *      </proerty>
    * </bean>
    * */

    @Email
//    @Value("${person.name}")
    private  String name;
    private  Integer age;
    private  boolean boss;
    private  Date birth;
```

#### @PropertySource

+ 加载指定的配置文件

```java
@PropertySource(value = {"classpath:person.properties"})
@Component
@ConfigurationProperties(prefix = "person")
@Validated
public class Person {
```

#### @ImportResource

+ 导入spring的配置文件（xml），让配置文件生效

+ springboot里没有spring配置文件生效，自己写的配置文件不能生效，想要让配置文件生效，把@ImportResource加载进来，@ImportResource标注在配置类上

+ Springboot推荐给容器添加添加组件的方式：推荐全注解

  + 配置类，相当于Spring配置文件

  + @Bean注解

    + ```
      /*
      * @Configuration指明该类是一个配置文件类，相当于之前的Spring配置文件
      *
      * 配置文件用<bean>标签添加组件，配置类用@Bean注解添加组件
      *
      * */
      
      
      @Configuration
      public class MyAppConfiguration {
      
          /*
          * 容器中组件的名字就是方法名
          * */
          @Bean
          public Person person() {
              return new Person();
          }
      
      }
      ```

